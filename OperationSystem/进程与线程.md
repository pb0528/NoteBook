# 进程与线程

操作系统中最核心的概念是*进程*：对正在运行程序的一个抽象。操作系统的其他所有内容都是围绕着进程的概念展开的。

伪并行：在1秒钟内，它可能运行多道程序，这样给用户一种并行的错觉。

并行：对于多核CPU而言，可以在同一时刻运行多道程序。

## 进程

在进程模型中，计算机上所有可运行的软件，通常包括操作系统，被组织程若干顺序进程（sequential process），简称进程（process）。一个进程就是正在执行的程序，包括程序计数器，寄存器和变量的当前值。从概念上将，每个进程都有自己的虚拟CPU，实际上，真正的CPU在各进程之间来回切换。这种快速切换称为**多道程序设计**。



一个进程是某个类型的一个活动，它有程序、输入、输出以及状态。单个处理机可以被若干进程共享，它使用某种调度算法决定何时停止一个进程的工作。

### 进程的创建

有四种原因导致创建进程：

1. 系统初始化
2. 执行了从事创建进程的系统调用
3. 用户请求创建进程
4. 一个批处理作业的初始化

Unix系统，只能由一个系统调用来创建新进程**fork**。

### 进程的终止

由四种原因导致进程终止

1. 正常退出（自愿）
2. 出错退出（自愿）
3. 严重错误
4. 被其它进程杀死



进程层次结构是一种树结构，可有单个进程产生多个进程实体

### 进程的状态

1. 运行态（该时刻进程实际占用CPU）
2. 就绪态（可运行，但因为其他进程正在运行而暂时停止）
3. 阻塞态（除非某种外部事件发生，否则进程不能运行）



### 进程的实现

为了实现进程模型，操作系统维护者一张表格，即进程表（process table)。该表象包含进程状态的信息、它的程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息，以及其他在进程由运行态转换到就绪态或阻塞时必须保存的信息，从而保证该进程能再次启动。

PCB中含由三部分：

进程管理：寄存器、程序计数器、程序状态字、堆栈指针、进程状态、优先级、调度参数、进程ID、父进程、进程组、信号、进程开始时间、使用的CPU时间、下次报警事件

存储管理：正文段指针，数据段指针、堆栈段指针

文件管理：根目录、工作目录、工作描述符、用户ID、组ID

[^中断发生后操作系统最底层的工作步骤]: s

1. 硬件压入堆栈程序计数器等
2. 硬件从中断向量装入新的程序计数器
3. 汇编语言过程保存寄存器
4. 汇编语言过程设置新的堆栈
5. C中断服务例程运行
6. 调度程序决定下一个将运行的进程
7. C过程返回值汇编
8. 汇编语言开始运行新的当前进程



## 线程

线程模型是基于：资源分组处理与执行分离开来。

进程：管理资源，其中有存放了程序正文和数据以及其他资源的地址空间。

线程：有一个程序计数器，用来记录接着执行那条指令，拥有寄存器，用来保存当前的工作变量，还拥有一个堆栈，用来记录执行历史，每一帧保存一个已调用但还未返回的过程。



### 线程的使用

需要线程的原因：在许多应用中同时发生多种活动，其中某些活动随着时间的进展会被阻塞。通过将这些应用分解程可以准并行运行的多个顺序线程，程序设计模型会变得简单。

优点：

1. 并行实体共享同一段地址空间和所有可用数据得能力
2. 线程附带得资源并不多，所以更容易创建，也更容易撤销
3. 若存在大量得计算和大量得I/O处理，拥有多个线程允许这些活动彼此重叠进行，从而加快应用执行的速度

### 实现的方法

1. 在用户空间中实现线程
2. 在内核中实现线程
3. 混合实现

### 进程间通信

### 竞态条件

两个或多个进程读写某些共享数据，而最后结果取决于最后运行时刻的精确时序的情况，称之为*竞态条件*。

### 临界区

要避免涉及共享内存、共享文件以及共享任何资源的情况都会引发与前面类似的错误的情况发生，关键时要找出某种途径来阻止多个进程同时读写共享的数据。

换言之，**互斥**即我们所需。

我们可以把共享内存进行访问的程序片段称为*临界区域*或者*临界区*，如果我们适当安排，使得两个进程不可能同时处于临界区中，就能避免竞争条件。

尽管这样的要求避免了竞态条件，但还不能保证共享数据的并发进程能够正确和高效地进行协作。一个好的执行策略，需要满足一下4个条件:

1. 任何两个进程不能同时处于其临界区
2. 不应对CPU的速度和数量做出任何假设
3. 临界区外的其他进程不得阻塞其他进程
4. 不得使进程无限期等待进入临界区

#### 几种互斥的实现方法

1.禁止中断

​	最简单的方法是使得每个进程进入临界区后立即禁止所有中断，并在就要离开之前再打开中断。禁止中断后，时钟中断也被屏蔽。CPU只有发生时钟中断或其他中断时才会进行进程切换，这样，在禁止中断之后CPU就不会切换到其他进程。

2.锁变量

​	作为第二种尝试，可以寻找一种软件解决方案。当一个进程想进入临界区时，它首先测试这把锁。如果该锁的值为0，则该进程将其设置为1并进入临界区。若这把锁的值已经为1，则该进程将等待直到其值变为0。

3.严格轮换法

​	第三种互斥的方法。几乎与本书中所有其他程序一样，这里的程序段用C程序编写（或偶尔用C++），而基本上不用像Java。

```
while(TRUE){
	while(turn != 0);
	critical_region();
	turn = 1;
	noncritical_region();
}

while(TRUE){
	while(turn != 1);
	critical_region();
	turn = 0;
	noncritical_region();
}
```

4.Peterson 解法

```
#define FALSE 0
#define TRUE  1
#define N     2

int turn;
int interested[N];
```

5.TSL指令



### 休眠与唤醒

Peterson解法和TSL解法都是正确的，但它们都有忙等待缺点。

现在来考察几条进程间的通信原语，它们在无法进入临界区时将阻塞，而不是忙等待。最简单的是sleep和wakeup。sleep是一个将引起调用进程阻塞的系统调用，即将挂起。

**生产者-消费者问题**

作为使用这些原语的一个例子，我们考虑*生产者-消费者*问题，也称作有界缓冲区（bounded-buffer）问题。

```
#define N 100
int count = 0;
void produce(void)
{
	int item;
	while(TRUE)
	{
		item = produce_item();
		if(count == N) sleep();
		insert_item(item);
		count = count+1;
		if(count == 1) wakeup(consumer);
	}
}

void consumer(void)
{
	int item;
	while(TRUE)
	{
		if(count == 0) sleep();
		item = remove_item();
		count = count -1;
		if(count == N-1) wakeup(producer);
		consume_item(item);
	}
}
```



### 信号量

它使用个整形变量来累计唤醒次数，供以后使用。在他的建议中引入了一个新的变量类型，称为**信号量(semaphore)**。

Dijkstra 建议设立两种操作：down 和 up（分别为一般化后的sleep和wakeup）。检查数值、修改变量值以及可能发生的休眠操作均为单一的、不可分割的*原子操作*完成。这种原子性对于解决同步问题和避免竞态条件是绝对必要的。

```
#define N 100
typedefine int semaphore;
semaphore mutex = 1;
semaphore empty = N;
semaphore full = 0;

void producer(void)
{
	int item;
	while(TRUE){
		item = produce_item();
		down(&empty);
		down(&mutex);
		insert_item(item);
		up(&mutex);
		up(&full);
	}
}

void consumer(void)
{
	int item;
	while(TRUE){
		down(&full);
		down(&mutex);
		item = remove_item();
		up(&item);
		up(&empty);
		consumer_item(item);
	}
}
```

#### 互斥信号量

如果不需要信号量的计数能力，有时可以使用信号量的一个简化版本，称为*互斥信号量*。

互斥信号量是一个可以处于两态之一的变量：解锁和加锁。这样，只需要一个二进制位表示，不过实际上，0表示解锁，而其他所有的值表示加锁。互斥信号量使用两个过程。当一个线程（或进程）需要访问临界区时，它调用mutex_lock。

另一方面，如果该互斥信号量已经加锁，调用线程被阻塞，直到在临界区中的线程完成并调用mutex_lock。如果多个线程被阻塞在该互斥信号量上。

有两种方案。第一种，有些共享数据结构



> 由于死锁的存在，使得信号量加减锁操作难度上升。

#### 管程

一个管程是由过程、变量、及数据结构等组成的集合，它们组成一个特殊的模块或软件包。进程可在任何需要的时候调用管程，但它们不能在管程之外声明的过程中直接访问管程内的数据结构。

管程有一个很重要的特性，即任一管程只能有一个活跃进程，这一特性使管程能有效完成互斥。



#### 消息传递

消息传递使用两条原语 **send**和**receive**，它们像信号量而不像管程，是系统调用而不是语言成分。

例如：

​	send(destination, &message);

和

​	receive(source, &message);

消息传递系统面临着许多信号量和管程所谓涉及到的问题和设计难点，特别是位于网络中的不同机器上的通信进程的情况。