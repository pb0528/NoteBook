# 死锁

在很多应用中，需要一个进程排他性地访问若干个资源而不是一种。若进程A请求使用扫描仪，并被授权使用。进程B首先请求CD刻录机，也被授权使用。现在A请求使用CD刻录机，但该请求在B释放CD刻录机前会被拒绝。但是，进程B非但不放弃CD刻录机，而且去请求扫描仪。这时，两个进程都会被阻塞，并且一直处于这样的状态。这种状况就是*死锁(deadlock)*



## 资源

在进程对设备、文件进行排他性访问时，有可能会出现死锁，为了尽可能使得死锁地讨论通用，我们把排他性使用地这类对象称为*资源(resource)*

### 可抢占资源和不可抢占资源

*可抢占资源*：可以从拥有它地进程中抢占而不发生任何副作用

*不可抢占资源*：在不引起相关地计算失败地情况下，无法把它从占有它地进程处抢占过来。

总地来说，死锁和不可抢占资源有关。有关可抢占资源地潜在死锁通常可以通过进程间地重新分配资源而化解。

在使用一个资源所需要地时间顺序可以用抽象的形式表示如下:

* 请求资源
* 使用资源
* 释放资源

### 资源获取



## 死锁概述

死锁的规范定义如下：

​	如果一个进程集合中每个进程都在等待只能由改组进程中其它进程才能发生的事件。那么，该进程组时死锁的。

### 死锁的条件

1. 互斥条件。每个资源要么已经分配给一个进程，要么可用
2. 占有和等待条件。已经得到某个资源的进程可以再请求新的资源
3. 不可抢占条件。分配给一个进程的资源不能强制性地被抢占，只能被占有它地进程显式地释放。
4. 环路等待条件。死锁发生时，系统中一定有由两个或者两个以上地进程组成地一条环路，该环路中每个进程都在等待下一个进程所占有的资源

### 死锁的预防

### 破坏互斥条件

先考虑破坏互斥条件。如果资源不被一个进程所独占，那么死锁肯定不会产生。

### 破坏占有和等待条件

禁止已持有资源的进程再等待其它资源便可以消除死锁。一种实现方法是规定所有进程在开始执行前请求所需全部资源。如果所需被全部资源可用，那么就将它们分配给这个进程，于是该进程能直到运行结束。如果有一个或多个资源正被使用，那么就不进行分配，进程等待。

### 破坏不可抢占条件

破坏第三比破坏第二更难

### 破坏循环等待条件

消除循环等待有几种方法：

1. 保证每个进程在任何时刻只能占有一个资源，如果需要另外一个资源，它必须先释放资源
2. 将所有资源统一编号。进程可以在任何时刻提出资源请求，但是所有请求必须接受按照资源编号的顺序（升序）提出。

## 其它相关问题

### 两阶段加锁

### 非资源死锁

### 饥饿

