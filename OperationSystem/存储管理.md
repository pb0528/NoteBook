# 存储管理

内存是计算机中一种必须加以认真管理的重要资源。

存储管理器的任务是记录哪些内容在使用，哪些内容是空闲，在进程需要时为其分配存储器，在进程使用完后释放存储器，而在主存太小无法装入所有进程时，管理主存和磁盘间的交换。

## 基本存储管理

我们可以把存储管理系统分成两类：一类是运行期间会在主存和磁盘间（交换和分页）移动进程的系统，另一类是不移动进程的系统。

之所以引入交换和分页，在很大程度上是因为没有足够的主存可以容纳全部的进程。

### 无交换或分页的单道程序设计

最简单可行的存储管理方案是一次只运行一个程序，该程序与操作系统共享内存。

一旦用户输入了一个命令，操作系统就把需要的程序从磁盘复制到内存中并执行它；当进程运行结束后，操作系统在用户终端显示提示符并等待新命令。

### 固定分区的多道程序设计

实现多道程序设计的最容易的办法是将内存划分成n个分区（各分区大小不等）。

### 重定位和保护

有多道程序设计带来的两个必须解决的重要问题时：重定位和保护。由于多道程序中，不同的地址有不同的作业运行。在连接某一程序时，连接程序必须了解程序将在内存的那个地方开始。

解决重定位问题的一个可能的方案是，但程序调入内存时直接对指令进行修改。

为了实现保护，IBM 360机器采用的办法是，把内存被划分为块，每块2kb，并且都分配有4位的保护码。

另一个解决重定位和保护问题就是在机器中设置两个专门的硬件寄存器，分别为基址寄存器和界限寄存器。在调度一个进程是，其分区的起始地址被装入基址寄存器，分区长度被装入界限寄存器。在被发送给内存之前，进程生成的每一个地址被自动加上基址寄存器的内容。界限寄存器自动检查地址，以确保它们没有试图访问当前分区以外的地址。如果基址寄存器包含的值是100k，一条CALL 100 指令实际上被转换位CALL 100K+100,而指令本身不用修改。

这个方案的一个缺点是每次内存引用都需要执行一次加法和一次比较。

```
存储管理有两种通用的方法，具体采用哪种取决于可用的硬件。最简单的策略是交换(swapping)，包括从整体上调入进程，是该进程运行一段时间，然后把它存回磁盘。另一种策略是虚拟存储器(virtual memory),该策略甚至使程序在只有一部分调入主存的情况下运行。
```



## 交换

在可变分区中，数量、位置、大小随着进程的出入是动态变化的，而在前者中它们是固定不变的。由于可变分区不再受到可能太大或太小的固定分区的约束，内存的利用率提高了，但它也使内存的分配和释放以及记录各个内存块的使用情况更加复杂。

交换产生了内存中的多个空闲区（hole，也称位空洞），通过把所有的进程尽可能向下移动，与可能将这些小的空闲区合成一大块。该技术称为*内存紧缩（memory compaction）*



在动态分配内存时，操作系统必须对其进行管理。一般而言，有两种方式跟踪内存使用情况：位图和空闲表。

### 使用位图的存储管理

### 使用链表的存储管理

## 虚拟存储器

基本思想：程序、数据和堆栈的总大小可能超过可用的物理内存的大小。有操作系统把程序当前使用的那些部分保留在主存中，而把其它部分保存在磁盘上。虚拟存储器也可以在多道程序设计系统中工作，许多程序的片段同时保存在内存中。



### 分页

在大多树虚拟存储器系统中都在使用一种分页技术，在任何一台计算机上，都存在一个程序能够产生的内存地址的集合。当程序执行下面的一条指令时：

> MOVE REG , 1000

它把地址为1000的内存单元的内容拷贝到REG中（或者两者相反，这取决于计算机的型号）。地址可以通过索引、基址寄存器、段寄存器或其他方式产生。

有程序产生的这些地址称为*虚拟地址*,它们构成了*虚拟地址空间*。在没有虚拟存储器的计算机上，系统直接将虚拟地址送到内存总线上，读写操作使用具有同样地址的物理内存字；而在使用虚拟存储器情况下，虚拟地址不是被直接送到内存总线上，而是被送到*内存管理单元（MMU）*MMU把虚拟地址映射为物理地址。



*虚拟地址空间*以 页面（page）为单位划分。在物理内存中对应的单位称为叶帧（page frame）。页面和叶帧大小总是一样的。

当程序试图访问地址0时，例如，使用下面这条命令：

> MOVE REG, 0

将虚拟地址0送到MMU。MMU看到虚拟地址落在0页面范围内（0~4095），根据其映射，这一页面对应的是页帧2（8192~12287），因此MMU把地址变换为8192，并把地址8192送到总线上。内存对MMU一无所知，它只看到一个读或写地址8192的请求并执行它。MMU从而有效地把所有从0~4095的虚拟地址映射到了8192~12287的物理地址。

通过恰当地设置MMU，可以把16个虚拟页面映射到8个叶帧中的任何一个。但是并没有解决虚拟地址空间比物理内存大的问题。当只有8个物理页帧时，于是只有8个虚拟页面被映射到了物理内存中，在实际地硬件中，用一个"在/不在"位（present/absent bit）记录哪一页面在内存中实际存在。



当程序试图使用未映射地页面时，如下：

> MOVE REG, 32780

MMU注意到这个页面没有被映射，于是使CPU陷入到操作系统中，这个页面称为页面失效（page fault）。操作系统找到一个很少使用的页帧并把它的内存写入磁盘，随后把需访问的页面取到刚才回收的页帧中，修改映射，然后重新启动引起陷阱的指令。



### 页表

虚拟地址被分成虚拟页号（高位）和偏移量（低位）两部分。

虚拟页面号可用做页表的索引，已找到该虚拟页面对应的页表表项。由页表表项，可以找到页帧号。然后页帧号被拼接到偏移量的高位端替换虚拟页面号，形成送往内存的物理地址。

页表的目的是吧虚拟页面映射为页帧。从数学角度说，页表是一个函数，它的参数时虚拟页面号，结果时物理页帧号。通过这个函数可以把虚拟内存中的页面域替换成页帧域，从而形成物理地址。

除了这些有关页表的简单介绍外，还必须考虑两个问题：

1. 页表有可能非常大
2. 映射必须非常快



#### 多级页表

为了避免始终在内存保存庞大的页表，许多计算机采用了多级页表。



### 页面置换算法

当发生页面失效时，操作系统必须在内存中国选择一个页面将其移除内存，以便为即将调入的页面让出空间。

#### 最优页面置换算法

#### 最近未使用页面置换算法

#### 先进先出页面置换算法

#### 第二次机会页面置换算法

#### 时钟页面置换算法

#### 最近最少使用页面置换算法

### 页面置换算法小结

| :算法:              | :注释:                   |
| ------------------- | ------------------------ |
| 最优算法            | 不可实现，但可以作为基准 |
| 工作集算法          | 实现起来开销较大         |
| 工作集时钟算法      | 好的有效算法             |
| NRU(最近未使用)算法 | 非常粗糙                 |
| FIFO(先进先出)算法  | 可能抛弃重要方面         |
| 第二次机会算法      | 比FIFO有大改善           |
| 时钟算法            | 现实                     |
| LRU(最久未使用)     | 很优秀，但很难实现       |
| NFU(最不经常使用)   |                          |
| 老化算法            | 非常近似LRU              |



### 共享内存

另一个设计问题就是共享处理。在大型多道程序设计系统中，几个不同的用户运行同一个程序是常见的。

共享数据比共享代码麻烦，但也不是不可能。特别是在UNIX中，在进行fork系统调用后，父进程和子进程要共享程序文本和数据。在分页系统中，通常是让这些进程分别拥有它自己的页表，但都指向同一个页面集合。

只要这两个进程都仅仅是读数据，而不是更改，这种情况就可以保持下去。但只要有一个进程更新了一点数据，就会违反制度保护，并引起操作系统陷阱。然后会生成一个该页面的副本，这样每个进程都有自己的专用副本。两个拷贝都是可以读写的，随后对任何一个副本的写操作都不会引发陷阱。这种策略就意味着那些从来不会执行写操作的页面就不需要进行复制。这种方法称为写时复制



### 有关实现的问题

#### 与分页有关的操作系统

操作系统要在下面四段事件里做与调页相关的工作：进程创建、进程执行、页面失效和终止。下面就分别对这四种情况进行考察：
当在分页系统中创建一个新进程时，操作系统要确定程序和数据最初会是多大，并为它们创建一个页表。要为页表在内存中分配空间并进行初始化。当进程被换出时，页表不需要驻留在内存中，但当进程运行时，它必须在内存中。另外，要在磁盘交换区分配空间，以便当一个进程换出时有位置可放。要用程序正文和数据对交换区初始化，这样当新进程页面失效时，可以从磁盘中调入该页面。某些系统直接从可执行文件对程序正文进行分页，以节省磁盘空间和初始化时间。最后，必须把有关页表和磁盘交换去的信息存储在进程表中。

当调度一个进程执行时，必须为新进程重置MMU，刷新TLB，以清除以前的进程所留下的痕迹。新进程的页表必须成为当前页表，通常可以通过复制改页表或者把一个指向它的指针放进某个硬件寄存器来完成。有时，一开始的时候就把部分或全部进程的页面装入内存可以减少页面失效的可能性。	

当页面发生失效时，操作系统必须通过都硬件寄存器来确定哪个虚拟地址造成页面失效。通过该信息，他要计算需要哪个页面，并在磁盘上对该页面进行定位。他必须找到合适的页帧来放新页面，必要时还要淘汰旧页面，然后把所需页面读入页帧。最后，还要恢复程序计数器，使程序计数器指向引起页面失效的指令，并重新执行该指令。

当程序退出时，操作系统必须释放进程的页表、页面和页面在磁盘上所占用的空间。如果某些页面是与其它进程共享的，当最后一个使用他们的进程终止的时候，就可以释放内存和磁盘上的页面了。

### 页面失效处理

处理顺序如下：

1. 硬件陷入内核，在堆栈中保存程序计数器。
2. 启动一个汇编代码例程保存通用寄存器和其他易失的信息，以免被操作系统破坏。这个例程将操作系统作为一个过程调用。
3. 当操作系统发现一个页面失效时，试图查找需要哪个虚拟页面。通常一个硬件寄存器包含了这一个信息
4. 一旦知道了发生页面失效的虚拟地址，操作系统检查这个地址是否有效，并检查存取与保护是否一致。如果不一致，想进程发出信号或者杀掉该进程。
5. 如果选的页帧”脏“了，安排将该页面写回磁盘，并发生一次上下文切换，挂起产生页面失效的进程，让其他进程运行直至磁盘传输结束。
6. 一旦页帧”干净“后，操作系统查找所需页面在磁盘上的地址，通过磁盘操作将其装入。
7. 当磁盘终端发生，表明该页面被装入，页表已更行以反映它的位置，页帧页标记为通常的状态。
8. 恢复发生页面失效指令以前的状态，程序计数器重新指向这条指令
9. 调度页面失效进程，操作系统返回调用它的汇编语言例程
10. 该例程恢复寄存器和其他状态信息，回到用户空间继续执行，就好像页面失效没有发生过。

### 分段

到目前位置我们讨论的虚拟存储器都是一维，虚拟地址从0到最大地址，一个地址接着另一个地址。对许多问题来说，有两个或多个独立的地址空间可能比只有一个要好得多。一个编译器在编译过程中会建立许多表，其中包括：

1. 被保存供打印清单用的源程序正文
2. 符号表，包含变量的名字和属性
3. 包含所用的所有整型量和浮点常量
4. 语法分析树，包含程序语法分析结果
5. 编译器内部过程调用使用的堆栈

前4个表随着编译进行不断增长，最后在编译过程中以一种不可预计的方式增长或者缩小。在一维存储器中，这5个表只能被分配到虚拟地址空间中连续的块中。如果有很多的变量，地址空间中分给符号表的块可能被装满。

为了方便程序从管理表的扩张和收缩的工作解放出来，一个只管并且非常通用的方法是在机器上提供多个互相独立的*段*的地址空间。

因为每个段都构成一个独立的地址空间，它们可以独立地增长或减小而不会影响其他地段。如果一个在某个段中的堆栈需要更多的空间来增长，他就可以立刻得到所需空间。

段是一个逻辑实体，一个段可能包括一个过程、一个数组、一个堆栈、一组数据变量，但一般它不会同时包含多种不同类型地内容。

分段管理地优点：

* 简化对长度经常变动的数据结构地处理
* 分段有助于在几个进程之间共享过程和数据。最常见的例子就是*共享库（shared library）*。